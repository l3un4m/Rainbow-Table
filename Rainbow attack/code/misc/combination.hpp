#ifndef COMBINATION_H
#define COMBINATION_H

#include "arithmetics.hpp"
#include <algorithm>
#include <array>
#include <iostream>
#include <limits>

//TODO: make common class for iterators ? They kinda look alike
//TODO: make template specializations for N=0 &&|| K=0

namespace rainbow {

/**
 * This class models a pascal triangle used in combinatorics to compute
 * the number of ways there are to choose <code>k</code> distinct objects
 * among a set of <code>n</code> objects, where the order in which these
 * objects are picked matters not, that is, to compute the binomial
 * coefficient (n k).
 * <p>
 * Note that the triangle is not computed until a call to
 * <code>operator()</code> is made. Furthermore, once
 * <code>operator(n,k)</code> has been called, every subsequent calls
 * to this operator with lower <code>n</code> or <code>k</code> are
 * performed in constant time.
 * <p>
 * Note that this class uses n * n * sizeof(N) bytes of dynamic
 * memory while instanciated.
 * @brief This class models a pascal triangle used to compute the
 * binomial coefficient indexed by a pair of given naturals
 */
//template<Natural N>
template<class N>
class PascalTriangle
{
    N size;
    N* array;

    N& memo(const N& n, const N& k) const;

    public:
        /**
         * Builds upp a pascal triangle used to compute and store binomial
         * coefficients up to some maximum value of a natural <code>n</code>.
         * @brief Builds upp a pascal triangle
         * @param n the maximum natural that will be used when computing
         * binomial coefficients (n k)
         */
        PascalTriangle(const N& n);

        /**
          * Standard destructor.
          */
        ~PascalTriangle();

        /**
          * Standard deleted copy constructor.
          */
        PascalTriangle(const PascalTriangle&) = delete;

        /**
          * Standard deleted copy-assign operator.
          */
        PascalTriangle& operator=(const PascalTriangle&) = delete;

        /**
          * Standard move constructor.
          */
        PascalTriangle(PascalTriangle&&) noexcept;

        /**
          * Standard move-assign operator.
          */
        PascalTriangle& operator=(PascalTriangle&&) noexcept;

        /**
         * Computes and returns the binomial coefficient (n k).
         * <p>
         * Note that when this function is called with some <code>n</code>
         * and some <code>k</code>, subsequent calls with lower
         * <code>n</code> or <code>k</code> are executed in constant time.
         * <p>
         * The behaviour of this function is undefined if <code>n</code>
         * is larger than the <code>n</code> provided in the constructor.
         * @brief Computes and returns the binomial coefficient (n k).
         * @param n the parameter <code>n</code> in the binomial coefficient (n k).
         * @param k the parameter <code>k</code> in the binomial coefficient (n k).
         * @return the binomial coefficient (n k).
         */
        N operator()(const N& n, const N& k);
};

/**
 * Returns the binomial coefficient indexed by a pair of given naturals.
 * <p>
 * This coefficient correspond to the number of ways there are to choose
 * <code>k</code> distinct objects among a set of <code>n</code> objects,
 * where the order in which these objects are picked matters not.
 * <p>
 * Should you need several consecutive calls to this function, it might be
 * significantly faster to directly use <code>PascalTriangle</code>.
 * <p>
 * Note that this algorithm uses n * n * sizeof(N) bytes of dynamic
 * memory while running.
 * @brief Returns the binomial coefficient indexed by a pair of given
 * naturals.
 * @return the binomial coefficient indexed by a pair of given naturals.
 * @see PascalTriangle
 */
template<Natural N>
N binom(N n, N k);

/**
 * A type alias for combinations, modeled as bit-arrays of specific length.
 */
template<size_t N>
using Combination = std::array<bool, N>;

/**
 * Operator overload to print combinations in output streams.
 * <p>
 * Note that this overload is also valid for <code>std::array<bool, N></code>
 * @param out the output stream to print the combination into
 * @param comb the combination to print
 * @return the output stream after printing the combination
 */
template<size_t N>
std::ostream& operator<<(std::ostream& out, const Combination<N>& comb)
{
    for(unsigned i = 0; i < N; i++)
        out << comb[i];

    return out;
}

template<std::size_t N>
class CombinationGenerator;

/**
 * This class allows to iterate on combinations generated by a
 * combination generator.
 * <p>
 * Note that since advancing such iterator on combinations to generate
 * actually generates the combinations, it may be unwanted to have multiple
 * iterators on the same generator.
 * @brief This class allows to iterate on combinations generated by a
 * combination generator.
 * @author R. Absil
 */
template<std::size_t N>
class CombinationIterator
{
    /**
     * Memory pointed by adresses is not allocated here.
     * Adresses are taken when instanciating (param by ref)
     * No need to worry about copy, affectation, destruction
     */
    CombinationGenerator<N> * gen;

    friend class CombinationGenerator<N>;

    CombinationIterator(CombinationGenerator<N>& gen);

    public:        
        /**
         * This operator returns the last combination generated by the
         * generator.
         * @brief This operator returns the last combination generated
         * by the generator.
         * @return  the last combination generated by the generator
         */
        inline Combination<N> operator*() const;

        /**
         * Advances the underlying iterator to the next combination to
         * generate.
         * @brief Advances the underlying iterator to the next combination
         * to generate.
         * @return an iterator starting on the next combination to generate
         */
        inline CombinationIterator<N> operator ++();

        /**
         * Returns true if the given iterator is different from the
         * underlying one, returns false otherwise.
         * @brief Returns true if the given iterator is different from the
         * underlying one.
         * @param i the iterator you want to check difference with
         * @return true if the given iterator is different from the
         * underlying one, returns false otherwise.
         */
        inline bool operator !=(const CombinationIterator<N>& i) const;
};

/**
 * This class is able to generate combinations of a set of fixed size
 * according to lexical order. It is also able to fast directly pick
 * the i<sup>th</sup> combination according to this order.
 * <p>
 * Note that, from a combinatorial point of view, this class generates
 * all selections of objects from a set of fixed size, that is, selections
 * of no element, selections of 1 element, selections of 2 elements, etc.
 * <p>
 * This class also provides mecanisms in order to iterate over generated
 * combinations wich "for each" like loops.
 * <p>
 * In this order, the identity combination (that is, no object is selected)
 * is the first combination. Thus, when iterating over combinations generated
 * by this class, the identity will always be the first combination returned.
 * <p>
 * Moreover, in this order, a combination a<sub>1</sub>a<sub>2</sub>
 * a<sub>3</sub>...a<sub>n</sub> of the set {1,2,...,n} precedes a
 * combination b<sub>1</sub>b<sub>2</sub>b<sub>3</sub>...b<sub>n</sub> if,
 * for some <i>k</i> with <i>1 <= k <= n</i>, we have <i>a<sub>1</sub> =
 * b<sub>1</sub>, a<sub>2</sub>=b<sub>2</sub>, a<sub>k-1</sub> = b<sub>k-1
 * </sub></i> and <i>a<sub>k</sub> < b<sub>k</sub></i>.
 * <p>
 * A combination is encoded as <code>std::array<bool,std::size_t></code>, where it is
 * assumed that the identity combination is encoded as <code>(0,0,0,...,0)
 * </code>, that is, element "at index 0" of the set is not taken, neither is
 * the element at index 1 etc. When an element is selected, it is set as 1,
 * while when it is not, it is set as zero.
 * @brief This class is able to generate combinations of a set of fixed
 * size.
 * @author R. Absil
 */
template<std::size_t N>
class CombinationGenerator
{    
    Combination<N> comb; //current combination

    std::size_t i; //index of current combination in lexicographic order

    std::size_t _2n;//2^N
    bool over; //are there more combinations to generate ?

    CombinationGenerator(bool);//for symbolicEnd (the bool is a phantom param)

    friend class CombinationIterator<N>;

    public:
        /**
         * Builds up a combination generator over a set of <code>n</code>
         * elements able to generate combinations according to lexical order.
         * @brief Builds up a combination generator over a set of <code>N
         * </code> elements.
         */
        CombinationGenerator();

        /**
         * Returns true if there are more combinations to generate, returns
         * false otherwise.
         * <p>
         * Basically, there are no more combinations of length <code>n</code>
         * to generate if already <code>2^n</code> combinations have been generated.
         * @brief Returns true if there are more combinations to generate, returns
         * false otherwise.
         * @return true if there are more combinations to generate, returns
         * false otherwise.
         */
        inline bool hasNext() const;

        /**
         * Returns the next combination to generate according to lexical order.
         * <p>
         * Note that the behaviour of this member function is undetermined if
         * a call to hasNext() returns <code>false</code>, that is, if there are
         * no more combinations to generate.
         * @brief Returns the next combination to generate according to lexical
         * order.
         * @return the next combination to generate according to lexical order.
         * @see hasNext()
         */
        Combination<N> next();

        /**
         * Picks the i<sup>th</sup> combination according to the lexical
         * order.
         * <p>
         * Note that this call does <i>not</i> generate all combinations
         * preceding the combination to generate by iterative call to next()
         * @brief Picks the i<sup>th</sup> combination according to the lexical
         * order.
         * @param i the index (according to lexical order) of the combination
         * to generate.
         * @return the i<sup>th</sup> combination according to the lexical
         * order.
         * @throw std::out_of_range if i >= 2^n
         */
        Combination<N> pick(std::size_t i) const;

        /**
         * Returns an iterator over combinations to generate.
         * <p>
         * The iterator is set to firstly reference the identity, that is, the
         * first combination according to lexical order. Advancing the iterator
         * will make it reference further combinations.
         * <p>
         * Note that since advancing such iterator on combinations to generate
         * actually generates the combinations, it may be unwanted to have multiple
         * iterators on the same generator.
         * @brief Returns an iterator over combinations to generate.
         * @return an iterator over combinations to generate.
         */
        inline CombinationIterator<N> begin();

        /**
         * Returns an iterator outside of the range of combinations to generate.
         * <p>
         * The behaviour of this iterator is as follows :
         * <ul>
         *  <li>if advanced, it remains out of range,</li>
         *  <li>if compared, it is equal to end() (that is, to itself),</li>
         *  <li>if compared, it is different to anything but end(),</li>
         *  <li>advancing an iterator generated by begin() beyond combination
         *  range sets it to end().</li>
         * </ul>
         * @brief Returns an iterator outside of the range of combinations to
         * generate.
         * @return an iterator outside of the range of combinations to generate.
         */
        inline CombinationIterator<N> end() const;
};

template<std::size_t N, std::size_t K>
class KCombinationGenerator;

/**
 * This class allows to iterate on combinations generated by a
 * k-combination generator.
 * <p>
 * Note that since advancing such iterator on k-combinations to generate
 * actually generates the combinations, it may be unwanted to have multiple
 * iterators on the same generator.
 * @brief This class allows to iterate on k-combinations generated by a
 * k-combination generator.
 * @author R. Absil
 */
template<std::size_t N, std::size_t K>
class KCombinationIterator
{
    KCombinationGenerator<N,K> * gen;

    friend class KCombinationGenerator<N,K>;

    KCombinationIterator(KCombinationGenerator<N,K>& gen);

    public:
        /**
         * This operator returns the last k-combination generated by the
         * generator.
         * @brief This operator returns the last k-combination generated
         * by the generator.
         * @return  the last k-combination generated by the generator
         */
        inline Combination<N> operator*() const;

        /**
         * Advances the underlying iterator to the next k-combination to
         * generate.
         * @brief Advances the underlying iterator to the next k-combination
         * to generate.
         * @return an iterator starting on the next k-combination to generate
         */
        inline KCombinationIterator<N,K> operator ++();

        /**
         * Returns true if the given iterator is different from the
         * underlying one, returns false otherwise.
         * @brief Returns true if the given iterator is different from the
         * underlying one.
         * @param i the iterator you want to check difference with
         * @return true if the given iterator is different from the
         * underlying one, returns false otherwise.
         */
        inline bool operator !=(const KCombinationIterator<N,K>& i) const;
};

/**
 * This class is able to generate combination of a set of fixed size
 * according to lexical order with exactly k objects selected. Such a
 * combination is called a k-combination. It is also able to fast directly pick
 * the i<sup>th</sup> k-combination according to this order.
 * <p>
 * Note that, from a combinatorial point of view, this class generates
 * all selections of objects from a set of fixed size, that is, selections
 * of no element, selections of 1 element, selections of 2 elements, etc.
 * <p>
 * This class also provides mecanisms in order to iterate over generated
 * k-combination wich "for each" like loops.
 * <p>
 * In this order, the identity k-combination (that is, no object is selected)
 * is the first k-combination. Thus, when iterating over k-combination generated
 * by this class, the identity will always be the first k-combination returned.
 * <p>
 * Moreover, in this order, a k-combination a<sub>1</sub>a<sub>2</sub>
 * a<sub>3</sub>...a<sub>n</sub> of the set {1,2,...,n} precedes a
 * k-combination b<sub>1</sub>b<sub>2</sub>b<sub>3</sub>...b<sub>n</sub> if,
 * for some <i>k</i> with <i>1 <= k <= n</i>, we have <i>a<sub>1</sub> =
 * b<sub>1</sub>, a<sub>2</sub>=b<sub>2</sub>, a<sub>k-1</sub> = b<sub>k-1
 * </sub></i> and <i>a<sub>k</sub> < b<sub>k</sub></i>.
 * <p>
 * A k-combination is encoded as <code>Nuple<bool,std::size_t></code>, where it is
 * assumed that the identity k-combination is encoded as <code>(0,0,0,...,0)
 * </code>, that is, element "at index 0" of the set is not taken, neither is
 * the element at index 1 etc. When an element is selected, it is set as 1,
 * while when it is not, it is set as zero.
 * @brief This class is able to generate k-combination of a set of fixed
 * size.
 * @author R. Absil
 */
template<std::size_t N, std::size_t K>
class KCombinationGenerator
{
    Combination<N> comb; //current combination

    std::size_t i; //index of current combination in lexicographic order

    std::size_t _nk;//(n k)
    bool over; //are there more combinations to generate ?

    KCombinationGenerator(bool);//for symbolicEnd (the bool is a phantom param)

    friend class KCombinationIterator<N,K>;
    public:

        /**
         * Builds up a k-combination generator over a set of <code>n</code>
         * elements able to generate k-combinations according to lexical order.
         * @brief Builds up a k-combination generator over a set of <code>N
         * </code> elements.
         */
        KCombinationGenerator();

        /**
         * Returns true if there are more k-combinations to generate, returns
         * false otherwise.
         * <p>
         * Basically, there are no more k-combinations of length <code>n</code>
         * to generate if already <code>2^n</code> k-combinations have been generated.
         * @brief Returns true if there are more k-combinations to generate, returns
         * false otherwise.
         * @return true if there are more k-combinations to generate, returns
         * false otherwise.
         */
        inline bool hasNext() const;

        /**
         * Returns the next k-combination to generate according to lexical order.
         * <p>
         * Note that the behaviour of this member function is undetermined if
         * a call to hasNext() returns <code>false</code>, that is, if there are
         * no more k-combinations to generate.
         * @brief Returns the next k-combination to generate according to lexical
         * order.
         * @return the next k-combination to generate according to lexical order.
         * @see hasNext()
         */
        Combination<N> next();

        /**
         * Picks the i<sup>th</sup> k-combination according to the lexical
         * order.
         * <p>
         * Note that this call does <i>not</i> generate all k-combinations
         * preceding the k-combination to generate by iterative call to next()
         * @brief Picks the i<sup>th</sup> k-combination according to the lexical
         * order.
         * @param i the index (according to lexical order) of the k-combination
         * to generate.
         * @return the i<sup>th</sup> k-combination according to the lexical
         * order.
         * @throw std::out_of_range if i >= (n k)
         */
        Combination<N> pick(std::size_t i) const;

        /**
         * Returns an iterator over k-combinations to generate.
         * <p>
         * The iterator is set to firstly reference the identity, that is, the
         * first k-combination according to lexical order. Advancing the iterator
         * will make it reference further k-combinations.
         * <p>
         * Note that since advancing such iterator on k-combinations to generate
         * actually generates the k-combinations, it may be unwanted to have multiple
         * iterators on the same generator.
         * @brief Returns an iterator over k-combinations to generate.
         * @return an iterator over k-combinations to generate.
         */
        inline KCombinationIterator<N,K> begin();

        /**
         * Returns an iterator outside of the range of k-combinations to generate.
         * <p>
         * The behaviour of this iterator is as follows :
         * <ul>
         *  <li>if advanced, it remains out of range,</li>
         *  <li>if compared, it is equal to end() (that is, to itself),</li>
         *  <li>if compared, it is different to anything but end(),</li>
         *  <li>advancing an iterator generated by begin() beyond k-combination
         *  range sets it to end().</li>
         * </ul>
         * @brief Returns an iterator outside of the range of k-combinations to
         * generate.
         * @return an iterator outside of the range of k-combinations to generate.
         */
        inline KCombinationIterator<N,K> end() const;        
};

//template<Natural N> //takes n * n * sizeof(Natural) bytes in memory
template<class N>
PascalTriangle<N>::PascalTriangle(const N& n) : size(n), array(new N[n * n])
{
    static auto zero = static_cast<N>(0);
    std::fill_n(array, size, zero);
}

//template<Natural N>
template<class N>
PascalTriangle<N>::~PascalTriangle()
{
    if(array != nullptr) //avoid double delete from move cstr
        delete[] array;
}

//template<Natural N>
template<class N>
PascalTriangle<N>::PascalTriangle(PascalTriangle&& triangle) noexcept : size(triangle.size), array(triangle.array)
{
    triangle.array = nullptr;
}

//template<Natural N>
template<class N>
PascalTriangle<N>& PascalTriangle<N>::operator=(PascalTriangle<N>&& triangle) noexcept
{
    delete[] array;
    size = triangle.size;
    array = triangle.array;
    triangle.array = nullptr;

    return *this;
}

//template<Natural N>
template<class N>
N& PascalTriangle<N>::memo(const N& n, const N& k) const
{
    return array[size * n + k];
}

//template<Natural N>
template<class N>
N PascalTriangle<N>::operator()(const N& n, const N& k)
{
    if(n == 0 || k == 0 || k == n)
        return 1;
    else if (k  > n)
        return 0;
    else if (k == 1)
        return n;

    //ALL HAIL DYNAMIC PROGRAMMING AND OUR GRANDMASTER BELLMAN !!!
    N v1 = memo(n - 1, k - 1);
    if (v1 == 0) //not memoized
        v1 = memo(n - 1, k - 1) = (*this)(n - 1, k - 1); //I'm sexy and I know it

    N v2 = memo(n - 1, k);
    if (v2 == 0)
        v2 = memo(n - 1, k) = (*this)(n - 1, k);

    return v1 + v2;
}

template<Natural N>
N binom(N n, N k) //takes n * n * sizeof(Natural) bytes in memory
{
    PascalTriangle<N> triangle(n);
    return triangle(n, k);
}

//fake constructor for end()
template<std::size_t N>
CombinationGenerator<N>::CombinationGenerator(bool) : comb(Combination<N>{}), i(0), _2n(0), over(true)
{}

template<std::size_t N>
CombinationGenerator<N>::CombinationGenerator() : comb(Combination<N>{}), i(0), _2n(pow(2, N)), over(false)
{
//    std::fill(comb.begin(), comb.end(), false);
}

template<std::size_t N>
bool CombinationGenerator<N>::hasNext() const
{
    return ! over;
}

template<std::size_t N>
Combination<N> CombinationGenerator<N>::next()
{
    if(i >= _2n + 1)
        return comb;
    else if(i != 0)
    {
        std::size_t j = N-1;
        for(; comb[j]; j--)
            comb[j] = false;
        comb[j] = true;
    }

    i++;
    over = i >= _2n;

    return comb;
}

template<std::size_t N>
Combination<N> CombinationGenerator<N>::pick(std::size_t i) const
{
    if(i >= _2n)
        throw std::out_of_range("Parameter must be between 0 and 2^n exclusive");

    Combination<N> comb {};
//    std::fill(comb.begin(), comb.end(), false);

    for(std::size_t j = N - 1; i != 0; j--)//I know : i != 0 -> it's not a bug
    {
        bool odd = i % 2 != 0;
        i /= 2;

        comb[j] = odd;// = r
    }

    return comb;
}

template<std::size_t N>
CombinationIterator<N>::CombinationIterator(CombinationGenerator<N> &gen) : gen(&gen)
{
    ++(*this);
}

template<std::size_t N>
CombinationIterator<N> CombinationGenerator<N>::begin()
{
    CombinationIterator<N> it(*this);
    return it;
}

template<std::size_t N>
CombinationIterator<N> CombinationGenerator<N>::end() const
{
    static CombinationGenerator<N> over(true);
    return CombinationIterator<N>(over);
}

template<std::size_t N>
Combination<N> CombinationIterator<N>::operator *() const
{
    return gen->comb;
}

template<std::size_t N>
CombinationIterator<N> CombinationIterator<N>::operator ++()
{
    gen->next();
    return *this;
}

template<std::size_t N>
bool CombinationIterator<N>::operator !=(const CombinationIterator<N>& i) const
{
//for some reason, buggy
//    if(gen->over && i.gen->over)
//        return false;
//    else if(gen->over || i.gen->over)
//        return true;

    //suspicious +1, I should investigate (but I probably never will since it passes unit tests)
    if(gen->i == gen->_2n + 1 && i.gen->i == i.gen->_2n + 1)
        return false;
    else if(gen->i == gen->_2n + 1 || i.gen->i == i.gen->_2n + 1)
        return true;
    else if(gen->i != i.gen->i)
        return true;
    else
        return false;
}

template<std::size_t N, std::size_t K>
KCombinationGenerator<N,K>::KCombinationGenerator(bool) : comb(Combination<N>{}), i(0), _nk(0), over(true)
{}

template<std::size_t N, std::size_t K>
KCombinationGenerator<N,K>::KCombinationGenerator() : comb(Combination<N>{}), i(0), _nk(binom(N, K)), over(false)
{
    if(N != K)
    {
//        std::fill(comb.begin(), comb.end(), false);
        if(K != 0)
            for(unsigned i = N - 1; (N - i - 1) < K && i > 0; i--)
                comb[i] = true;
    }
    else
        std::fill(comb.begin(), comb.end(), true);
}

template<std::size_t N, std::size_t K>
bool KCombinationGenerator<N,K>::hasNext() const
{
    return ! over;
}

template<std::size_t N, std::size_t K>
Combination<N> KCombinationGenerator<N,K>::next()
{
    if(i >= _nk + 1)
        return comb;
    else if(i != 0)
    {
        unsigned j = N - 1;
        while(! comb[j]) //find first non zero
            j--;
        unsigned count = 0;
        while(j < N && comb[j]) //after, most significant 1
        {
            count++;
            j--;
        }
        if(j >= N) //controlled overflow if most significant 1 is on bit 0
        {
            i++;
            over = true;
            return comb;
        }
        else
        {
            comb[j] = true; //set next bit to 1
            count--;
            j++;
            while(j < N - count) //set every previous bit to zero
            {
                comb[j] = false;
                j++;
            }

            while(j < N) //set as many 1 in the end
            {
                comb[j] = true;
                j++;
            }
        }
    }

    i++;
//    over = i >= _nk; //not needed because of controlled overflow

    return comb;
}

template<std::size_t N, std::size_t K>
Combination<N> KCombinationGenerator<N,K>::pick(size_t i) const
{
    if(i >= _nk)
        throw std::out_of_range("Parameter must be between 0 and (n k) exclusive");
    i++; //next algorithm starts at i=1

    static PascalTriangle<std::size_t> n_choose_k(N);//we will cache values of (n, k)
    Combination<N> comb {};

    auto n = N;
    auto k = K;
    unsigned index = 0;
    while(n <= N) //controlled overflow
    {
        if(n > k)
        {
            if(i > n_choose_k(n - 1, k))
            {
                comb[index] = true;
                i -= n_choose_k(n - 1, k);
                k--;
            } //else, bit is set to zero, but it already is
        }
        else
        {
            comb[index] = true;
            k--;
        }
        index++;
        n--;
    }

    return comb;
}

template<std::size_t N, std::size_t K>
KCombinationIterator<N,K>::KCombinationIterator(KCombinationGenerator<N,K> &gen) : gen(&gen)
{
    ++(*this);
}

template<std::size_t N, std::size_t K>
KCombinationIterator<N,K> KCombinationGenerator<N,K>::begin()
{
    KCombinationIterator<N,K> it(*this);
    return it;
}

template<std::size_t N, std::size_t K>
KCombinationIterator<N,K> KCombinationGenerator<N,K>::end() const
{
    static KCombinationGenerator<N,K> over(true);
    return KCombinationIterator<N,K>(over);
}

template<std::size_t N, std::size_t K>
Combination<N> KCombinationIterator<N,K>::operator *() const
{
    return gen->comb;
}

template<std::size_t N, std::size_t K>
KCombinationIterator<N,K> KCombinationIterator<N,K>::operator ++()
{
    gen->next();
    return *this;
}

template<std::size_t N, std::size_t K>
bool KCombinationIterator<N,K>::operator !=(const KCombinationIterator<N,K>& i) const
{
//for some reason, buggy
//    if(gen->over && i.gen->over)
//        return false;
//    else if(gen->over || i.gen->over)
//        return true;

    //suspicious +1, I should investigate (but I probably never will since it passes unit tests)
    if(gen->i == gen->_nk + 1 && i.gen->i == i.gen->_nk + 1)
        return false;
    else if(gen->i == gen->_nk + 1 || i.gen->i == i.gen->_nk + 1)
        return true;
    else if(gen->i != i.gen->i)
        return true;
    else
        return false;
}


}//namespace rainbow

#endif // COMBINATION_H
